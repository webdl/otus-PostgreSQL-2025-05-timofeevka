# Работа с журналами
Цели:
* уметь работать с журналами и контрольными точками
* уметь настраивать параметры журналов

# Решение домашнего задания
## Подготовка сервера
Перед началом работ следует очистить каталог с текущими wal-файлами, если используется не свежеустановленный сервер.

### Немного теории
WAL-файлы в PostgreSQL удаляются после того, как они становятся ненужными для восстановления и репликации. Основные моменты:
- WAL-файлы хранятся в каталоге `pg_wal` и имеют фиксированный размер (обычно 16МБ, согласно параметру `wal_buffers`).
- При запуске **контрольной точки (checkpoint)** PostgreSQL фиксирует состояние базы, обновляет файлы данных и оценивает, сколько 
  сегментов WAL нужно сохранить для восстановления.
- После контрольной точки старые WAL-файлы, которые уже не нужны для восстановления, **перерабатываются (переименовываются и повторно 
  используются) или удаляются**, если их количество превышает минимально необходимое `min_wal_size` и не превышает максимально 
  допустимое `max_wal_size`
- Если размер WAL на диске превышает `min_wal_size`, старые сегменты WAL удаляются при освобождении пространства, иначе они 
  перезаписываются.
- В случае репликации WAL-файлы не удаляются, пока все реплики не подтвердят получение и применение соответствующих записей. Если 
  репликация отстает, файлы накапливаются, чтобы обеспечить возможность восстановления на репликах
- Для очистки архивированных WAL-файлов можно использовать утилиту `pg_archivecleanup`, которая удаляет файлы, архивированные до 
  определённой точки резервного копирования

Но, это всё в теории... На практике же оказывается, что PostgreSQL очень неохотно расстается с захваченным им местом. Об этом далее.

### Сокращение количества wal-файлов с помощью функции
Для начала перенастройкой параметров `min_wal_size` и `max_wal_size`, которые в моем случае равны 1Gb и 4Gb соответственно. Так как сервер 
активно работал до этого, то в каталоге `/mnt/pg_data/main/pg_wal` скопилось 3.7Gb wal-файлов.

В файле `postgresql.conf` задаем параметры:
```
max_wal_size = '200MB'
min_wal_size = '100MB'
```
и перезапускаем сервер:
```shell
> pg_ctlcluster 16 main restart
```

К сожалению этого недостаточно, чтобы PostgreSQL освободил занимаемое место. И даже выполнение команды `CHECKPOINT;` тоже не поможет. 

Причина такого поведения описана в пункте 3 раздела Немного теории выше — пока PostgreSQL не пройдется по этим файлам повторно, то есть 
не задействует эти wal-файлы для записи новых журналов — он не удалит их. Если у вас сервер с малым трафиком, например, сервер для 
разработки, и вы недавно выполнили операцию, которая создала много записей (например, импорт данных), то количество wal-файлов может 
вырасти вплоть до максимально разрешённого размера (max_wal_size).

Чтобы принудительно заставить сервер пройтись по всем существующим wal-файлам и удалить лишние, можно использовать специальную функцию, 
которая повторно вызывает команду переключения на новый wal-файл (pg_switch_wal()). Также запускается контрольная точка (checkpoint),
которая записывает текущие изменения на диск и «закрывает» старый wal-файл. Делая это, сервер уменьшит количество wal-файлов до текущего 
значения max_wal_size или даже меньше.

Однако подобное действие может быть нежелательным на работающем сервере, особенно если у вас настроено архивирование WAL — оно может 
замедлиться или работать некорректно. Поэтому эту процедуру стоит применять только если ваш сервер соответствует описанной ситуации 
(малый трафик, много старых WAL-файлов после масштабной операции). В зависимости от того, сколько у вас файлов WAL, выполнение этой 
операции может занять некоторое время.

```sql
create or replace function pg_wal_cycle_all() 
returns int language plpgsql 
as $$
declare
    wal_count int;
    wal_seg varchar;
begin 
    select count(*) - 1 
    into wal_count 
    from pg_ls_dir('pg_wal');

    for wal in 1..wal_count loop 
        select pg_walfile_name(pg_switch_wal()) into wal_seg;
        raise notice 'segment %', wal_seg;
        checkpoint;
    end loop;
    return wal_count;
end;$$;

-- Выполнить функцию
select pg_wal_cycle_all();
```

### Сокращение количества wal-файлов с pgbench
Как альтернативный вариант вышеописанному способу. Если запустить его на любой БД (так как wal-файлы общие для всего сервера), то он 
своей работой заполнит wal-файлы и PostgreSQL удалит пройденные файлы. Пример:
```shell
> pgbench -i -s 10 persons
> pgbench -c 10 -j 2 -t 50000 persons
```

## Настройка сервера
Вернем предыдущие настройки `min_wal_size` и `max_wal_size` и зададим параметр `checkpoint_timeout` равный 30. Также, чтобы отслеживать 
выполнение контрольных точек, выставим параметры `logging_collector` и `log_checkpoints` в значение "on" (по умолчанию последний уже задан,
но не будет лишним прописать его принудительно). Все настройки производятся через файл [db.yml](../deploy/vm/group_vars/db.yml).

Срез измененных настроек:
```
min_wal_size = 1GB
max_wal_size = 4GB
logging_collector = on
log_checkpoints = on
```

Применим настройки через команду ниже и дождемся перезапуска кластера:
```shell
> ansible-playbook playbooks/install_db.yml -l db
```

### Проверка логирования контрольных точек
Найдем расположение лог-файлов:
```sql
SHOW data_directory; -- каталог с данными
SHOW log_directory;  -- каталог с лог-файлами в каталоге с данными
```
В моем случае лог-файлы находятся по пути `/mnt/pg_data/main/log`, а сам лог-файл называется `postgresql-2025-08-02_093617.log`.

Выполним shell-команду потокового чтения файла:
```shell
> tail -f /mnt/pg_data/main/log/postgresql-2025-08-02_093617.log
```

Выполним принудительную запись контрольной точки:
```sql
CHECKPOINT;
```

Увидим, что контрольные точки логируются:
```
2025-08-02 09:40:49.732 UTC [7221] LOG:  checkpoint starting: immediate force wait
2025-08-02 09:40:49.747 UTC [7221] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.001 s, total=0.016 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=0 kB; lsn=32/CD36E7A8, redo lsn=32/CD36E770
```
